\documentclass{beamer}
\usepackage[utf8]{inputenc}

\input{../common/setup.tex}

\newcommand\strong\textbf

\title{Introduction to Akka}

\author{Mikhail Limanskiy}

\institute{SymphonyTeleca}

\date{\today}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\begin{frame}{About Akka}
Akka is an open-source toolkit and runtime simplifying the construction of concurrent
and distributed applications on the JVM. Akka supports multiple programming models
for concurrency, but it emphasizes actor-based concurrency, with inspiration drawn from Erlang.\\~\\

Akka is written in Scala, but provides bindings both for Scala and Java.\\~\\

First public release 0.5 was announced in January of 2010. Current release 2.3.2 (April 2014).
\end{frame}

\begin{frame}{Actors Model}
The Actor model adopts the philosophy that everything is an \emph{actor}.  In Akka all \linline{Actor}s
live in \linline{ActorSystem}.\\~\\

Actor can:
\begin{itemize}
\item handle a message from it's mailbox
\item send message to another actors
\item create other actors
\item watch if the child actor is dead and recreate it
\end{itemize}
Actors interacts with each other \strong{only} by sending messages.\\~\\

Actors are executed concurrently.  It allows to run actors not only on different CPUs, but on the
different hosts in the network.
\end{frame}

\begin{frame}[fragile]
\frametitle{Actor class}
The \linline{Actor} class is abstract base for all actors. Main methods are:
\begin{itemize}
  \item \linline{receive: PartialFunction[Any, Unit]} -- abstract method handling incoming messages.
  \item \linline{self: ActorRef} -- returns self reference
  \item \linline{sender: ActorRef} -- reference to actor of the last received message.
  \item \linline{context: ActorContext} -- provides actor context.
\end{itemize}
\begin{lstlisting}
class Hello extends Actor {
  def receive = {
    name: String => println ("Hello, " + name)
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Props and ActorRef}
You shall never create actors using \linline{new}. You need use \linline{actorOf} method of the
\linline{ActorSystem} or the actor context.\\~\\

\linline{Props} class specify which actor will be created.\\~\\

As result you will receive \linline{ActorRef} instance which is a proxy object for the real actors.
It has two main methods to send messages:
\begin{itemize}
\item \linline{!} -- send message and forget (also known as \linline{tell}).
\item \linline{?} -- send message and get \linline{Future} for result (also known as \linline{ask}).
\item \linline{pipeTo} -- send future result.
\end{itemize}
\begin{example}
\begin{lstlisting}
val system = ActorSystem("testsystem")
val hello = system.actorOf(Props[Hello])
hello ! "World"
\end{lstlisting}
\end{example}
\end{frame}

\begin{frame}[fragile]
\frametitle{Behaviours}
You can change actor behaviour on runtime by switching to another message handling function instead
of receive. Use following \linline{context} methods:
\begin{itemize}
\item \linline{become(behavior:Receive,discardOld:Boolean=true)}
\item \linline{unbecome(): Unit}
\end{itemize}
\end{frame}

\begin{frame}{The end}
\centering
\textbf{That's all folks!}
\end{frame}

\end{document}
