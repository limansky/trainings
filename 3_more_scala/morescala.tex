\documentclass{beamer}
\usepackage[utf8]{inputenc}

\input{../common/setup.tex}

\title{Advanced Scala programming}
\subtitle{extractors, parsers}

\author{Mikhail Limanskiy}

\institute{SymphonyTeleca}

\date{\today}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\section{Extractors}

\begin{frame}[fragile]
\frametitle{Recap: pattern matching}
Pattern matching is a Scala feature similar to switch/case operator, but allows you to match
using much more complex rules:
\begin{example}
\begin{lstlisting}
val l = List(1, 8, 4,  2, 5, 12)
l.sorted find (_ > 3) match {
  case Some(x) => println("$x is a smallest value greater than 3 in the list")
  case None    => println("There are no values greater than 3")
}

def getSecond(l: List[A]): Option[A] = l match {
  case _::x::_ => Some(x)
  case _       => None
}
\end{lstlisting}
\end{example}
\end{frame}

\begin{frame}[fragile]
\frametitle{Case classes}
You can match on any classes, but using \linline{case class}es allows you to match on constructors.
Also, when you define case class:
\begin{itemize}
\item creates factory method with a same name (you can create instances without using new)
\item creates values for each constructor parameter
\end{itemize}
\begin{example}
\begin{lstlisting}
sealed abstract class Result[T]
case class Success[T](value: T) extends Result
case class Error(message: String) extends Result

def divide(x: Int, y: Int) = 
  if (y == 0) Error("Division by 0") else Success(x / y)

divide(25, 7) match {
  case Success(r) => println("Result is $r")
  case Failure(m) => println(m)
}
\end{lstlisting}
\end{example}
\end{frame}

\begin{frame}[fragile]
\frametitle{Extractors}

Extractors allows you to use pattern matching without case classes. Extractor is an object with
method \linline{unapply}.

\begin{example}
\begin{lstlisting}
import scala.util.Try

object Twice {
  def apply(x: Int) = x * 2
  def unapply(z: Int) = if (z % 2 == 0) Some(z / 2) else None
}

object AsInt {
  def unapply(s: String) = Try(s.toInt).toOption
}

def printHalf(x: Int) = x match {
  case Twice(y) => println(s"$x is two times $y")
  case _        => println("x is odd")
}

def foo(s: String) = s match {
  case AsInt(Twice(y)) => println("The half is " + y)
  case _               => println("Wrong input")
}
\end{lstlisting}
\end{example}
\end{frame}

\section{Parsers}

\begin{frame}[fragile]
\frametitle{Combinatoric parsers}
Combinatoric parsers is the easy way to build complex parsers from the small parsers blocks.
Main combinators are:
\begin{itemize}
\item \linline{~} -- sequential composition
\item \linline{|} -- alternative composition
\item \linline{~>} and \linline{<~} -- sequence ignoring right or left value.
\item \linline{rep} or \linline{*} -- repeat parser
\item \linline{rep1} or \linline{+} -- repeat at least once
\item \linline{opt} or \linline{?} -- optional parser
\item \linline{repsep} -- repeated parser with separator
\item \linline{^^} -- convert parsed value using function.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Parsing CSV example}
\begin{lstlisting}
import scala.util.parsing.combinator.RegexParsers
import scala.io.Source

abstract class Cell
case class NumCell(number: Double) extends Cell
case class StringCell(string: String) extends Cell

trait CSVParser extends RegexParsers {
  override def skipWhitespace = false
  def lf = "\n"
  def space = "[ \t]*".r

  def number: Parser[NumCell] = 
    space ~> """-?\d+(\.\d*)?""".r <~ space ^^ { x => NumCell(x.toDouble) }
  
  def string: Parser[StringCell] = """[^,\n]*""".r ^^ { StringCell }

  def cell: Parser[Cell] = number | string
  def line: Parser[List[Cell]] = repsep(cell, ",") <~ lf
  def file: Parser[List[List[Cell]]] = rep(line)
}

object FileParser extends App with CSVParser {

  val str = Source.fromFile(args.head).mkString
  parseAll(file, str) match {
    case Success(result, _) => result foreach (l => println(l.mkString("\t")))
    case fail: NoSuccess    => println("Parsing failed" + fail.msg)
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Calculator using parsers}
Defining a model:
\begin{lstlisting}[name=calc]
import scala.util.parsing.combinator.JavaTokenParsers

abstract class Expr {
  val eval: Double
}

case class Add(a: Expr, b: Expr) extends Expr {
  override val eval = a.eval + b.eval
}

case class Sub(a: Expr, b: Expr) extends Expr {
  override val eval = a.eval - b.eval
}

case class Mul(a: Expr, b: Expr) extends Expr {
  override val eval = a.eval * b.eval
}

case class Div(a: Expr, b: Expr) extends Expr {
  override val eval = a.eval / b.eval
}

case class Num(a: Double) extends Expr {
  override val eval = a
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Calculator using parsers, continuation}
Defining parser:
\begin{lstlisting}[name=calc]
trait CalcParser extends JavaTokenParsers {
  def num = floatingPointNumber ^^ (s => Num(s.toDouble))

  def plus: Parser[Expr => Expr] = "+" ~> term ^^ (x => Add(_, x))

  def minus: Parser[Expr => Expr] = "-" ~> term ^^ (x => Sub(_, x))

  def times: Parser[Expr => Expr] = "*" ~> factor ^^ (x => Mul(_, x))

  def div: Parser[Expr => Expr] = "/" ~> factor ^^ (x => Div(_, x))

  def sum: Parser[Expr] = term ~ rep(plus | minus) ^^ {
      case a ~ b => b.foldLeft(a)((i, f) => f(i))
  }

  def term: Parser[Expr] = factor ~ rep(times | div) ^^ {
      case a ~ b => b.foldLeft(a)((i, f) => f(i))
  }

  def factor = num | "(" ~> sum <~ ")"
}

object Calculator extends App with CalcParser {
  parseAll(sum, args.mkString) match {
    case Success(e, _) => println("Result: " + e.eval)
    case fail: NoSuccess    => println("Parsing failed: " + fail.msg)
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Calculator without model}

We can also create calculator without any model, returning doubles and functions:

\begin{lstlisting}
import scala.util.parsing.combinator.JavaTokenParsers

trait SimpleCalc extends JavaTokenParsers {
  def num: Parser[Double] = floatingPointNumber ^^ (x => x.toDouble)
  def plus: Parser[Double => Double] = "+" ~> term ^^ (x => _ + x)
  def minus: Parser[Double => Double] = "-" ~> term ^^ (x => _ - x)
  def times: Parser[Double => Double] = "*" ~> factor ^^ (x => _ * x)
  def div: Parser[Double => Double] = "/" ~> factor ^^ (x => _ / x)
  def sum: Parser[Double] = term ~ rep(plus | minus) ^^ {
      case a ~ b => b.foldLeft(a)((i, f) => f(i))
  }
  def term: Parser[Double] = factor ~ rep(times | div) ^^ {
      case a ~ b => b.foldLeft(a)((i, f) => f(i))
  }
  def factor = num | "(" ~> sum <~ ")"
}

object CalcNoTree extends App with SimpleCalc {
  parseAll(sum, args.mkString) match {
    case Success(e, _) => println("Result: " + e)
    case fail: NoSuccess    => println("Parsing failed: " + fail.msg)
  }
}
\end{lstlisting}
\end{frame}

\section{String interpolation}

\begin{frame}[fragile]
\frametitle{String interpolation}

String interpolation is a powerful feature available in Scala since 2.10.  It allows to embed variable
references in \emph{processed} string literals.

String interpolators available out of box:
\begin{itemize}
\item \linline{s} allows use variables directly in the string.
\item \linline{f} provides formating features similar to \linline{printf} function.
\item \linline{raw} similar to \linline{s}, but doesn't escape literals within the string.
\end{itemize}

\begin{example}
\begin{lstlisting}
val world = "World"
println(s"Hello $world!")

val employees = Map("Bob" -> 1.8d, "Alice" -> 1.66d, "Carl" -> 1.75d)
employees.foreach(e => println(f"${e._1}%s is ${e._2}%2.2f meters tall"))
\end{lstlisting}
\end{example}
\end{frame}

\begin{frame}[fragile]
\frametitle{Implementing interpolators}

When Scala compiler found \linline{name"Content"} in your code it transforms it into the same name method call
of \linline{StringContext} class.  So, to create own interpolator we can create \emph{implicit class} and add
a new method to \linline{StringContext}.

\begin{lstlisting}
implicit class CapsHelper(val sc: StringContext) extends AnyVal {
  def caps(args: Any*): String = {
    sc.s(args: _*).toUpperCase
  }
}

println(caps"Hello, $world!")
\end{lstlisting}

\end{frame}

\begin{frame}{Bibliography}
\begin{thebibliography}{00}
\bibitem{scala}Martin Odersky, Lex Spoon, Bill Venners:
\emph{Programming in Scala},
Artima, 2nd edition, 2011
\end{thebibliography}
\end{frame}

\input{../common/theend.tex}

\end{document}
